/// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.23;

import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ERC1155TokenReceiver} from "@solmate/tokens/ERC1155.sol";

import {MEME20} from "./MEME20.sol";
import {MEME1155} from "./MEME1155.sol";
import {MEME721} from "./MEME721.sol";
import {MEME20Constant} from "../libraries/MEME20Constant.sol";

/// @title Trugly's MEME404
/// @notice Contract automatically generated by https://www.trugly.meme
contract MEME404 is MEME20 {
    using FixedPointMathLib for uint256;
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       EVENTS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       ERRORS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /// @dev No tiers are provided
    error NoTiers();
    /// @dev Too many tiers are provided
    error MaxTiers();
    /// @dev When a fungible sequence has upperId that is not equal to lowerId
    error InvalidTierSequenceFungibleThreshold();
    /// @dev When a prev tier has a higher amount threshold than the current tier
    error InvalidTierSequenceAmountThreshold();
    /// @dev When a non-fungible sequence has incorrect upperId and lowerId
    error InvalidTierSequenceNonFungibleIds();

    /// @dev tokenId is 0
    error InvalidTierSequenceZeroId();

    /// @dev Only NFT collection can call this function
    error OnlyNFT();

    /// @dev When the contract is already initialized
    error TiersAlreadyInitialized();

    /// @dev When there's not enough NFTS based on amount threshold
    error InvalidTierSequenceNotEnoughNFTs();

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       STORAGE                     */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    struct Tier {
        string baseURL;
        uint256 lowerId;
        uint256 upperId;
        uint256 amountThreshold;
        bool isFungible;
        address nft;
        uint256 curIndex;
        uint256[] burnIds;
    }

    struct TierCreateParam {
        string baseURL;
        string nftName;
        string nftSymbol;
        uint256 amountThreshold;
        uint256 nftId;
        uint256 lowerId;
        uint256 upperId;
        bool isFungible;
    }

    /// @dev NFT ID to NFT address mapping
    mapping(uint256 => address) public nftIdToAddress;

    /// @dev Tier ID to Tier mapping
    mapping(uint256 => Tier) public tiers;

    uint256 public tiersCount;

    bool private _initialized;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       IMPLEMENTATION              */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    constructor(string memory _name, string memory _symbol, address _creator) MEME20(_name, _symbol, _creator) {}

    /// @dev Initialize the tiers
    /// @dev Is called automatically by the Memeception contract
    function initializeTiers(TierCreateParam[] memory _tiers) external {
        if (_initialized) revert TiersAlreadyInitialized();
        _initialized = true;

        if (_tiers.length == 0) revert NoTiers();
        if (_tiers.length > 10) revert MaxTiers();

        for (uint256 i = 0; i < _tiers.length; i++) {
            if (_tiers[i].lowerId == 0) revert InvalidTierSequenceZeroId();
            if (_tiers[i].amountThreshold == 0 || _tiers[i].amountThreshold > totalSupply) {
                revert InvalidTierSequenceAmountThreshold();
            }
            if (_tiers[i].isFungible) {
                if (_tiers[i].lowerId != _tiers[i].upperId) revert InvalidTierSequenceFungibleThreshold();
            } else {
                if (_tiers[i].lowerId >= _tiers[i].upperId) revert InvalidTierSequenceNonFungibleIds();

                uint256 maxNFT = totalSupply.rawDiv(_tiers[i].amountThreshold);
                if ((_tiers[i].upperId - _tiers[i].lowerId + 1) < maxNFT) revert InvalidTierSequenceNotEnoughNFTs();
            }

            address existingNFTAddr = nftIdToAddress[_tiers[i].nftId];
            Tier memory tier = Tier({
                baseURL: _tiers[i].baseURL,
                lowerId: _tiers[i].lowerId,
                upperId: _tiers[i].upperId,
                amountThreshold: _tiers[i].amountThreshold,
                isFungible: _tiers[i].isFungible,
                nft: address(0),
                curIndex: _tiers[i].lowerId,
                burnIds: new uint256[](0)
            });
            if (i > 0) {
                Tier memory previousTier = tiers[i - 1];
                if (previousTier.amountThreshold >= tier.amountThreshold) revert InvalidTierSequenceAmountThreshold();
                if (existingNFTAddr != address(0) && previousTier.upperId >= tier.lowerId) {
                    revert InvalidTierSequenceNonFungibleIds();
                }
            }
            tier.nft = existingNFTAddr != address(0) ? existingNFTAddr : _createNewNFT(creator, _tiers[i]);
            tiers[i] = tier;
        }

        tiersCount = _tiers.length;
    }

    /// @dev Transfer of memecoins
    /// @dev If balance of sender or recipient changes tier, mint or burn NFTs accordingly
    function transfer(address to, uint256 amount) public override returns (bool) {
        int256 beforeTierFrom = _getTierEligility(msg.sender);
        int256 beforeTierTo = _getTierEligility(to);
        bool success = super.transfer(to, amount);
        int256 afterTierFrom = _getTierEligility(msg.sender);
        int256 afterTierTo = _getTierEligility(to);

        _handleTierBurnAndMint(msg.sender, to, beforeTierFrom, beforeTierTo, afterTierFrom, afterTierTo);

        return success;
    }

    /// @dev Transfer of memecoins
    /// @dev If balance of sender or recipient changes tier, mint or burn NFTs accordingly
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        int256 beforeTierFrom = _getTierEligility(from);
        int256 beforeTierTo = _getTierEligility(to);
        bool success = super.transferFrom(from, to, amount);

        int256 afterTierFrom = _getTierEligility(from);
        int256 afterTierTo = _getTierEligility(to);

        _handleTierBurnAndMint(from, to, beforeTierFrom, beforeTierTo, afterTierFrom, afterTierTo);

        return success;
    }

    /// @dev Create a new NFT collection
    /// @notice ERC1155 if fungible, ERC721 if non-fungible
    function _createNewNFT(address _creator, TierCreateParam memory _tier) internal returns (address) {
        if (_tier.isFungible) {
            MEME1155 nft = new MEME1155(_tier.nftName, _tier.nftSymbol, _creator, _tier.baseURL);
            nftIdToAddress[_tier.nftId] = address(nft);
        } else {
            MEME721 nft = new MEME721(_tier.nftName, _tier.nftSymbol, _creator, _tier.baseURL);
            nftIdToAddress[_tier.nftId] = address(nft);
        }

        return nftIdToAddress[_tier.nftId];
    }

    /// @dev Handle minting and burning of NFTs based on tier changes
    function _handleTierBurnAndMint(
        address from,
        address to,
        int256 beforeTierFrom,
        int256 beforeTierTo,
        int256 afterTierFrom,
        int256 afterTierTo
    ) internal {
        // burn first
        if (beforeTierFrom != afterTierFrom) _burnTier(from, beforeTierFrom);
        if (beforeTierTo != afterTierTo) _burnTier(to, beforeTierTo);

        // Mint 2nd
        if (beforeTierFrom != afterTierFrom) _mintTier(from, afterTierFrom);
        if (beforeTierTo != afterTierTo) _mintTier(to, afterTierTo);
    }

    /// @notice Can only be called by NFT collection
    /// @dev Raw transfer of memecoins
    /// @dev This function bypasses the NFT mint/burn, approval and any fees
    function rawTransferFrom(address from, address to, uint256 nftTokenId) public returns (bool) {
        Tier memory tier = _getTierFromNftTokenId(msg.sender, nftTokenId);
        if (tier.nft == address(0)) revert OnlyNFT();
        balanceOf[from] -= tier.amountThreshold;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += tier.amountThreshold;
        }

        emit Transfer(from, to, tier.amountThreshold);

        return true;
    }

    /// @dev Mint NFTs once a user reaches a new tier
    /// @param _owner Address of the user
    /// @param tierId new Tier ID
    function _mintTier(address _owner, int256 tierId) internal {
        if (tierId < 0 || _owner == address(0)) return;

        Tier storage tier = tiers[uint256(tierId)];
        if (tier.isFungible) {
            if ((_owner.code.length != 0) && !_checkERC1155Received(_owner, msg.sender, address(0), tier.lowerId, 1)) {
                return;
            }
            MEME1155 nft = MEME1155(tier.nft);
            if (nft.balanceOf(_owner, tier.lowerId) >= 1) return;
            nft.mint(_owner, tier.lowerId, 1, "");
        } else {
            MEME721 nft = MEME721(tier.nft);
            if (nft.balanceOf(_owner) >= 1) return;

            uint256 burnIdsLength = tier.burnIds.length;
            uint256 nftIdToMint;
            if (burnIdsLength > 0) {
                nftIdToMint = tier.burnIds[burnIdsLength - 1];
                tier.burnIds.pop();
            } else {
                if (tier.curIndex <= tier.upperId) {
                    nftIdToMint = tier.curIndex++;
                }
            }

            nft.mint(_owner, nftIdToMint);
        }
    }

    /// @dev Burn NFTs once a user reaches a new tier (either going up or down)
    /// @param _owner Address of the user
    /// @param tierId new Tier ID
    function _burnTier(address _owner, int256 tierId) internal {
        if (tierId < 0 || _owner == address(0)) return;

        Tier storage tier = tiers[uint256(tierId)];
        if (tier.isFungible) {
            MEME1155 nft = MEME1155(tier.nft);
            if (nft.balanceOf(_owner, tier.lowerId) == 0) return;
            nft.burn(_owner, tier.lowerId, nft.balanceOf(_owner, tier.lowerId));
        } else {
            MEME721 nft = MEME721(tier.nft);
            if (nft.balanceOf(_owner) == 0) return;

            uint256 nftIdToburn = nft.tokenIdByOwner(_owner);
            nft.burn(nftIdToburn);
            tier.burnIds.push(nftIdToburn);
        }
    }

    /// @dev Get the tier eligibility of a user based on their memecoin balance
    /// @param _owner Address of the user
    /// @return Tier ID
    function _getTierEligility(address _owner) internal view returns (int256) {
        uint256 balance = balanceOf[_owner];
        for (uint256 i = tiersCount - 1; i >= 0; i--) {
            if (balance >= tiers[i].amountThreshold) {
                return int256(i);
            }
            if (i == 0) return -1;
        }
        return -1;
    }

    /// @dev Get the tier by ID
    /// @param tierId Tier ID
    /// @return Tier
    function getTier(uint256 tierId) public view returns (Tier memory) {
        return tiers[tierId];
    }

    /// @dev Get the tier by NFT token ID
    /// @param nft NFT address
    /// @param tokenId NFT token ID
    /// @return Tier
    function _getTierFromNftTokenId(address nft, uint256 tokenId) internal view returns (Tier memory) {
        for (uint256 i = 0; i < tiersCount; i++) {
            Tier memory tier = tiers[i];
            if (tier.nft != nft) continue;

            if (tier.isFungible) {
                if (tier.lowerId == tokenId) {
                    return tier;
                }
            } else {
                if (tokenId >= tier.lowerId && tokenId <= tier.upperId) {
                    return tier;
                }
            }
        }
        return Tier({
            baseURL: "",
            lowerId: 0,
            upperId: 0,
            amountThreshold: 0,
            isFungible: false,
            nft: address(0),
            curIndex: 0,
            burnIds: new uint256[](0)
        });
    }

    function _checkERC1155Received(address _contract, address _operator, address _from, uint256 _id, uint256 _value)
        internal
        returns (bool)
    {
        bytes memory callData = abi.encodeWithSelector(
            ERC1155TokenReceiver(_contract).onERC1155Received.selector, _operator, _from, _id, _value, ""
        );

        (bool success, bytes memory returnData) = _contract.call(callData);

        // Check both call success and return value
        if (success && returnData.length >= 32) {
            // Make sure there is enough data to cover a `bytes4` return
            bytes4 returned = abi.decode(returnData, (bytes4));
            return returned == ERC1155TokenReceiver.onERC1155Received.selector;
        }

        return false;
    }
}
