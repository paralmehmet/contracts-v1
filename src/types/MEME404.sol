/// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.23;

import {MEME20} from "./MEME20.sol";
import {MEME1155} from "./MEME1155.sol";
import {MEME721} from "./MEME721.sol";
import {MEME20Constant} from "../libraries/MEME20Constant.sol";

/// @title Trugly's MEME404
/// @notice Contract automatically generated by https://www.trugly.meme
contract MEME404 is MEME20 {
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       EVENTS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       ERRORS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/

    /// @dev No tiers are provided
    error NoTiers();
    /// @dev When a fungible sequence has upperId that is not equal to lowerId
    error InvalidTierSequenceFungibleThreshold();
    /// @dev When a prev tier has a higher amount threshold than the current tier
    error InvalidTierSequenceAmountTreshold();
    /// @dev When a non-fungible sequence has incorrect upperId and lowerId
    error InvalidTierSequenceNonFungibleIds();

    /// @dev tokenId is 0
    error InvalidTierSequenceZeroId();

    /// @dev Only NFT collection can call this function
    error OnlyNFT();

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       STORAGE                     */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    struct Tier {
        string baseURL;
        uint256 lowerId;
        uint256 upperId;
        uint256 amountThreshold;
        bool isFungible;
        address nft;
        uint256 curIndex;
        uint256[] burnIds;
    }

    struct TierCreateParam {
        string baseURL;
        string nftName;
        string nftSymbol;
        uint256 amountThreshold;
        uint256 nftId;
        uint256 lowerId;
        uint256 upperId;
        bool isFungible;
    }

    /// @dev Total number of tiers
    uint256 public tiersCount;

    /// @dev NFT ID to NFT address mapping
    mapping(uint256 => address) public nftIdToAddress;

    /// @dev Tier ID to Tier mapping
    mapping(uint256 => Tier) public tiers;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       IMPLEMENTATION              */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    modifier onlyNFT(uint256 nftId) {
        if (msg.sender != nftIdToAddress[nftId]) revert OnlyNFT();
        _;
    }

    constructor(string memory _name, string memory _symbol, address _creator, TierCreateParam[] memory _tiers)
        MEME20(_name, _symbol, _creator)
    {
        if (_tiers.length == 0) revert NoTiers();

        _mint(msg.sender, MEME20Constant.TOKEN_TOTAL_SUPPLY);
        creator = _creator;

        /// TODO: Add validations for making sure that there's enough lowerIds and upperIds based on amountThreshold

        for (uint256 i = 0; i < _tiers.length; i++) {
            if (_tiers[i].lowerId == 0) revert InvalidTierSequenceZeroId();
            if ((_tiers[i].isFungible) && (_tiers[i].lowerId != _tiers[i].upperId)) {
                revert InvalidTierSequenceFungibleThreshold();
            }
            address existingNFTAddr = nftIdToAddress[_tiers[i].nftId];
            Tier memory tier = Tier({
                baseURL: _tiers[i].baseURL,
                lowerId: _tiers[i].lowerId,
                upperId: _tiers[i].upperId,
                amountThreshold: _tiers[i].amountThreshold,
                isFungible: _tiers[i].isFungible,
                nft: address(0),
                curIndex: _tiers[i].lowerId,
                burnIds: new uint256[](0)
            });
            if (i > 0) {
                Tier memory previousTier = tiers[i - 1];
                if (previousTier.amountThreshold >= tier.amountThreshold) revert InvalidTierSequenceAmountTreshold();
                if (existingNFTAddr != address(0) && previousTier.upperId >= tier.lowerId) {
                    revert InvalidTierSequenceNonFungibleIds();
                }
            }
            tier.nft = existingNFTAddr != address(0) ? existingNFTAddr : _createNewNFT(_creator, _tiers[i]);

            tiers[i] = tier;
        }
        tiersCount = _tiers.length;
    }

    /// @dev Create a new NFT collection
    /// @notice ERC1155 if fungible, ERC721 if non-fungible
    function _createNewNFT(address _creator, TierCreateParam memory _tier) internal returns (address) {
        if (_tier.isFungible) {
            MEME1155 nft = new MEME1155(_tier.nftName, _tier.nftSymbol, _creator, _tier.baseURL, _tier.nftId);
            nftIdToAddress[_tier.nftId] = address(nft);
        } else {
            MEME721 nft = new MEME721(_tier.nftName, _tier.nftSymbol, _creator, _tier.baseURL, _tier.nftId);
            nftIdToAddress[_tier.nftId] = address(nft);
        }

        return nftIdToAddress[_tier.nftId];
    }

    /// @dev Transfer of memecoins
    /// @dev If balance of sender or recipient changes tier, mint or burn NFTs accordingly
    function transfer(address to, uint256 amount) public override returns (bool) {
        int256 beforeTierFrom = _getTierEligility(msg.sender);
        int256 beforeTierTo = _getTierEligility(to);
        bool success = super.transfer(to, amount);
        int256 afterTierFrom = _getTierEligility(msg.sender);
        int256 afterTierTo = _getTierEligility(to);

        _handleTierBurnAndMint(msg.sender, to, beforeTierFrom, beforeTierTo, afterTierFrom, afterTierTo);

        return success;
    }

    /// @dev Transfer of memecoins
    /// @dev If balance of sender or recipient changes tier, mint or burn NFTs accordingly
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        int256 beforeTierFrom = _getTierEligility(from);
        int256 beforeTierTo = _getTierEligility(to);
        bool success = super.transferFrom(from, to, amount);

        int256 afterTierFrom = _getTierEligility(from);
        int256 afterTierTo = _getTierEligility(to);

        _handleTierBurnAndMint(from, to, beforeTierFrom, beforeTierTo, afterTierFrom, afterTierTo);

        return success;
    }

    function _handleTierBurnAndMint(
        address from,
        address to,
        int256 beforeTierFrom,
        int256 beforeTierTo,
        int256 afterTierFrom,
        int256 afterTierTo
    ) internal {
        // burn first
        if (beforeTierFrom != afterTierFrom) _burnTier(from, beforeTierFrom);
        if (beforeTierTo != afterTierTo) _burnTier(to, beforeTierTo);

        // Mint 2nd
        if (beforeTierFrom != afterTierFrom) _mintTier(from, afterTierFrom);
        if (beforeTierTo != afterTierTo) _mintTier(to, afterTierTo);
    }

    /// @notice Can only be called by NFT collection
    /// @dev Raw transfer of memecoins
    /// @dev This function bypasses the NFT mint/burn
    function rawTransferFrom(uint256 nftId, address from, address to, uint256 amount)
        public
        onlyNFT(nftId)
        returns (bool)
    {
        return super.transferFrom(from, to, amount);
    }

    /// @dev Mint NFTs once a user reaches a new tier
    /// @param _owner Address of the user
    /// @param tierId new Tier ID
    function _mintTier(address _owner, int256 tierId) internal {
        if (tierId < 0) return;

        Tier storage tier = tiers[uint256(tierId)];
        if (tier.isFungible) {
            MEME1155 nft = MEME1155(tier.nft);
            if (nft.balanceOf(_owner, tier.lowerId) >= 1) return;
            nft.mint(_owner, tier.lowerId, 1, "");
        } else {
            MEME721 nft = MEME721(tier.nft);
            if (nft.balanceOf(_owner) >= 1) return;

            uint256 burnIdsLength = tier.burnIds.length;
            uint256 nftIdToMint;
            if (burnIdsLength > 0) {
                nftIdToMint = tier.burnIds[burnIdsLength - 1];
                tier.burnIds.pop();
            } else {
                if (tier.curIndex <= tier.upperId) {
                    nftIdToMint = tier.curIndex++;
                }
            }

            nft.mint(_owner, nftIdToMint);
        }
    }

    /// @dev Burn NFTs once a user reaches a new tier (either going up or down)
    /// @param _owner Address of the user
    /// @param tierId new Tier ID
    function _burnTier(address _owner, int256 tierId) internal {
        if (tierId < 0) return;

        Tier storage tier = tiers[uint256(tierId)];
        if (tier.isFungible) {
            MEME1155 nft = MEME1155(tier.nft);
            if (nft.balanceOf(_owner, tier.lowerId) == 0) return;
            nft.burn(_owner, tier.lowerId, nft.balanceOf(_owner, tier.lowerId));
        } else {
            MEME721 nft = MEME721(tier.nft);
            if (nft.balanceOf(_owner) == 0) return;

            uint256 nftIdToburn = nft.nftIdByOwner(_owner);
            nft.burn(nftIdToburn);
            tier.burnIds.push(nftIdToburn);
        }
    }

    /// @dev Get the tier eligibility of a user based on their memecoin balance
    function _getTierEligility(address _owner) internal view returns (int256) {
        uint256 balance = balanceOf[_owner];
        for (uint256 i = tiersCount - 1; i >= 0; i--) {
            if (balance >= tiers[i].amountThreshold) {
                return int256(i);
            }
            if (i == 0) return -1;
        }
        return -1;
    }

    /// @dev Get the tier details
    function getTier(uint256 tierId) public view returns (Tier memory) {
        return tiers[tierId];
    }
}
