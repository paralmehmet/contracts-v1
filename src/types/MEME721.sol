/// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.23;

import {ERC721, ERC721TokenReceiver} from "@solmate/tokens/ERC721.sol";
import {LibString} from "@solmate/utils/LibString.sol";
import {IMEME404} from "../interfaces/IMEME404.sol";

import {MEME20Constant} from "../libraries/MEME20Constant.sol";

/// @title Trugly's MEME721
/// @notice Contract automatically generated by https://www.trugly.meme
contract MEME721 is ERC721 {
    using LibString for uint256;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       ERRORS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    // @dev Only memecoin can call this function
    error OnlyMemecoin();

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       STORAGE                     */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    address public creator;
    address public memecoin;
    string public baseURI;

    /// @dev A uint32 map in storage.
    struct Uint32Map {
        uint256 spacer;
    }

    struct Owner {
        /// @dev list of tokenIds owned by the address
        Uint32Map ids;
    }

    /// @dev Mapping from address to Owner
    mapping(address => Owner) internal _owners;

    /// @dev Mapping from token ID to Owners.ids index position
    mapping(uint256 => uint256) internal _uint32MapIndex;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       IMPLEMENTATION              */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    modifier onlyMemecoin() {
        if (msg.sender != memecoin) revert OnlyMemecoin();
        _;
    }

    constructor(string memory name, string memory _symbol, address meme404, address _creator, string memory _baseURI)
        ERC721(name, _symbol)
    {
        creator = _creator;
        memecoin = meme404;
        baseURI = _baseURI;
    }

    function tokenURI(uint256 id) public view override returns (string memory) {
        return bytes(baseURI).length > 0 ? string.concat(baseURI, id.toString()) : "";
    }

    function transferFrom(address from, address to, uint256 id) public override {
        require(from == _ownerOf[id], "WRONG_FROM");

        require(to != address(0), "INVALID_RECIPIENT");

        require(
            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id], "NOT_AUTHORIZED"
        );

        if (from == to) {
            emit Transfer(from, to, id);
            return;
        }

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            _balanceOf[from]--;

            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        /// @notice Handle From custom storage
        Owner storage fromOwner = _owners[from];

        uint32 lastOwnedTokenId = _get(fromOwner.ids, _balanceOf[from] + 1);
        if (lastOwnedTokenId != uint32(id)) {
            _set(fromOwner.ids, _uint32MapIndex[id], lastOwnedTokenId);
            _uint32MapIndex[lastOwnedTokenId] = _uint32MapIndex[id];
        }

        /// @notice Handle To custom storage
        Owner storage toOwner = _owners[to];

        /// @dev Add the NFT id to the beginning to handle properly burn
        /// in MEME404 contract such that nextOwnedTokenId will point to
        /// previous NFT
        if (_balanceOf[to] > 1) {
            uint256 firstOwnedTokenId = _get(toOwner.ids, 1);

            _set(toOwner.ids, 1, uint32(id));
            _set(toOwner.ids, _balanceOf[to], uint32(firstOwnedTokenId));
            _uint32MapIndex[id] = 1;
            _uint32MapIndex[firstOwnedTokenId] = _balanceOf[to];
        } else {
            _set(toOwner.ids, _balanceOf[to], uint32(id));
            _uint32MapIndex[id] = _balanceOf[to];
        }

        delete getApproved[id];

        emit Transfer(from, to, id);

        IMEME404(memecoin).transferFromNFT(from, to, id);
    }

    function mint(address account, uint256 id) external onlyMemecoin {
        _safeMint(account, id);

        Owner storage owner = _owners[account];
        _set(owner.ids, _balanceOf[account], uint32(id));
        _uint32MapIndex[id] = _balanceOf[account];
    }

    function burn(uint256 id) external onlyMemecoin {
        Owner storage owner = _owners[_ownerOf[id]];
        uint32 lastOwnedTokenId = _get(owner.ids, _balanceOf[_ownerOf[id]]);

        if (lastOwnedTokenId != uint32(id)) {
            _set(owner.ids, _uint32MapIndex[id], lastOwnedTokenId);
            _uint32MapIndex[lastOwnedTokenId] = _uint32MapIndex[id];
        }
        _uint32MapIndex[id] = 0;

        _burn(id);
    }

    /// @dev Returns the uint32 value at `index` in `map`.
    function _get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {
        /// @solidity memory-safe-assembly
        assembly {
            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.
            result := and(0xffffffff, shr(shl(5, and(index, 7)), sload(s)))
        }
    }

    /// @dev Updates the uint32 value at `index` in `map`.
    function _set(Uint32Map storage map, uint256 index, uint32 value) internal {
        /// @solidity memory-safe-assembly
        assembly {
            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.
            let o := shl(5, and(index, 7)) // Storage slot offset (bits).
            let v := sload(s) // Storage slot value.
            sstore(s, xor(v, shl(o, and(0xffffffff, xor(value, shr(o, v))))))
        }
    }

    function nextOwnedTokenId(address account) external view returns (uint256) {
        return _get(_owners[account].ids, _balanceOf[account]);
    }
}
