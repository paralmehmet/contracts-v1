/// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.23;

import {ERC1155, ERC1155TokenReceiver} from "@solmate/tokens/ERC1155.sol";
import {LibString} from "@solmate/utils/LibString.sol";
import {MEME404} from "./MEME404.sol";

import {MEME20Constant} from "../libraries/MEME20Constant.sol";

/// @title Trugly's MEME404
/// @notice Contract automatically generated by https://www.trugly.meme
contract MEME1155 is ERC1155 {
    using LibString for uint256;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       ERRORS                      */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    // @dev Only memecoin can call this function
    error OnlyMemecoin();

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       STORAGE                     */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    string public name;
    string public symbol;
    address public creator;
    address public memecoin;
    string public baseURI;

    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    /*                       IMPLEMENTATION              */
    /* ¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯¯\_(ツ)_/¯*/
    modifier onlyMemecoin() {
        if (msg.sender != memecoin) revert OnlyMemecoin();
        _;
    }

    constructor(string memory _name, string memory _symbol, address _creator, string memory _baseURI) {
        name = _name;
        symbol = _symbol;
        creator = _creator;
        memecoin = msg.sender;
        baseURI = _baseURI;
    }

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data)
        public
        override
    {
        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        for (uint256 i = 1; i <= amount; i++) {
            MEME404(memecoin).transferFromNFT(from, to, id);
        }

        balanceOf[from][id] -= amount;
        balanceOf[to][id] += amount;

        emit TransferSingle(msg.sender, from, to, id, amount);

        require(
            to.code.length == 0
                ? to != address(0)
                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data)
                    == ERC1155TokenReceiver.onERC1155Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) public override {
        require(ids.length == amounts.length, "LENGTH_MISMATCH");

        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");

        // Storing these outside the loop saves ~15 gas per iteration.
        uint256 id;
        uint256 amount;

        for (uint256 i = 0; i < ids.length;) {
            id = ids[i];
            amount = amounts[i];

            for (uint256 j = 1; j <= amount; j++) {
                // This should never happen as each wallet should only have one NFT
                MEME404(memecoin).transferFromNFT(from, to, id);
            }

            balanceOf[from][id] -= amount;
            balanceOf[to][id] += amount;

            // An array can't have a total length
            // larger than the max uint256 value.
            unchecked {
                ++i;
            }
        }

        emit TransferBatch(msg.sender, from, to, ids, amounts);

        require(
            to.code.length == 0
                ? to != address(0)
                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data)
                    == ERC1155TokenReceiver.onERC1155BatchReceived.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function uri(uint256 id) public view override returns (string memory) {
        return bytes(baseURI).length > 0 ? string.concat(baseURI, id.toString()) : "";
    }

    function mint(address account, uint256 id, uint256 amount, bytes memory data) external onlyMemecoin {
        _mint(account, id, amount, data);
    }

    function burn(address account, uint256 id, uint256 amount) external onlyMemecoin {
        _burn(account, id, amount);
    }
}
